207. 课程表
中等
提示
你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。

例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。

 

示例 1：

输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
示例 2：

输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
 

提示：

1 <= numCourses <= 2000
0 <= prerequisites.length <= 5000
prerequisites[i].length == 2
0 <= ai, bi < numCourses
prerequisites[i] 中的所有课程对 互不相同


思路：
错误思路：
判断图中是否有环，如果访问到的节点之前已经访问过，则存在环。（错误，不是充分条件）
由于遍历的起点是随机的，所以可能会构建一个子图的拓扑。
需要对未访问节点重复上述步骤，需要一个拓扑编号来区分节点是上一次拓扑排序访问的，还是本次拓扑排序访问的。

正确思路：
构建图的拓扑排列，对与任何边 u->v，u在排列中都在v前面。
起点一定是没有入边的点（可能有多个），将所有起点加入排列，并将起点的出边都删除。后续要考虑的节点时被删除出边的终止节点（因为这些节点的入度都减少为0时，则变为新的起点）。
循环不变性：所有入度为0的节点要么在排列中，要么在起点集合中。
当新起点集合为空时，则找到了最大排列，如果有节点不在排列中，说明存在环。

伪代码：
遍历所有边，构建每个节点的入边和出边集合

初始化当前队列为取出所有入度为0的节点
对当前队列做广度优先遍历
    节点数-=队列长度
    处理所有子节点
        删除子节点中已当前节点开始的入边，如果子节点的入度为0，将子节点加入下一层节点列表

节点数>0，则存在环

坑点：
不要将必要条件当成充分条件，访问到已读节点不代表存在环

易错点：
只有当节点删除时，才删除子节点的入度边。
由于可能存在环，深度遍历时需要维护节点的访问状态，并忽略已访问的子节点