105. 从前序与中序遍历序列构造二叉树
中等
给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。


示例 1:
![alt text](<../../img/tree (1).jpg>)

输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
示例 2:

输入: preorder = [-1], inorder = [-1]
输出: [-1]
 

提示:

1 <= preorder.length <= 3000
inorder.length == preorder.length
-3000 <= preorder[i], inorder[i] <= 3000
preorder 和 inorder 均 无重复 元素
inorder 均出现在 preorder
preorder 保证 为二叉树的前序遍历序列
inorder 保证 为二叉树的中序遍历序列

思路：
根据深度优先遍历的特点，子树的遍历结果是连续的，因此只要找到左右子树的遍历结果的分界点就能将问题分解成左子树和右子树这两个子问题，可以用递归进行实现。

先序遍历数组的首位的值就是树的根节点的值
    如果起始下标相等，直接返回空节点

    遍历中序找到中序遍历根节点值所在的下标

    开端到下标就是左子树中旬遍历结果，长度为下标-开端
    下标+1到结尾就是右子树的中序遍历结果
    先序遍历切片开始+1到开始+左子树中旬长度的偏移量对应的子序列是左子树的前序遍历
    先序遍历开始+左子树中旬长度的偏移量+1的偏移量开始，到切片结束的子序列是右子树的前序遍历结果

    递归处理左子树的前、中旬结果生成左子树
    递归处理右子树的前、中旬结果生成右子树
返回根节点

边界情况：
iStart iEnd为中序遍历的起始下标
使用中序遍历的下标来判断迭代停止，由于split必定在中序列表中，因此必定满足split>=iStart,split<=iEnd
对于叶子节点的左右子树为空节点，对应的就是iStart==iEnd的情况。